Task 10: Bit Map-Introduction, XOR, AND, OR, right shift, left shift.-CO3-K3
Reverse bits of a given 32 bits unsigned integer. Note:
Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in

Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.
Example 1:
Input: n = 00000010100101000001111010011100
Output:    964176192 (00111001011110000010100101000000)
Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.
Example 2:
Input: n = 11111111111111111111111111111101
Output: 3221225471 (10111111111111111111111111111111)
Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.
Constraints:
The input must be a binary string of length 32.
Algorithm:
Take the 32-bit unsigned integer as input in binary format.
Convert the binary string into a character array.
Initialize two pointers: one pointing to the beginning of the array (i.e., the most significant bit), and the other pointing to the end of the array (i.e., the least significant bit).
Swap the bits at the two pointers and increment the first pointer and decrement the second pointer until they meet or cross each other.
Convert the modified character array back to a binary string.
Convert the binary string to an integer and return the result.
Program:
#include <stdio.h>
unsigned int reverseBits(unsigned int num) { unsigned int reversed = 0;
int bits = sizeof(num) * 8;
for (int i = 0; i < bits; i++) { if (num & (1 << i)) {
reversed |= 1 << (bits - 1 - i);
}
}

return reversed;
}

int main() {
unsigned int num = 10; printf("%u\n", num); printf("%u\n", reverseBits(num)); return 0;
} OUTPUT: 10
1342177280

Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).
Note:
Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3.
Example 1:
Input: n = 00000000000000000000000000001011
Output: 3
Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.
Example 2:
Input: n = 00000000000000000000000010000000
Output: 1
Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit. Example 3:
Input: n = 11111111111111111111111111111101
Output: 31
Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.
Constraints:
The input must be a binary string of length 32.
3. The Hamming distance between two integers is the number of positions at which the corresponding bits are different.
Give two integers x and y, return the Hamming distance between them. Example 1:
Input: x = 1, y = 4 Output: 2 Explanation:
1  (0 0 0 1)
4  (0 1 0 0)
↑ ↑
The above arrows point to positions where the corresponding bits are different. Example 2:
Input: x = 3, y = 1 Output: 1 Constraints:
0 <= x, y <= 231 – 1
Algorithm:
Algorithm for counting number of 1 bits in an unsigned integer:
Initialize a variable count to 0.
Loop through each bit in the 32-bit integer.
If the current bit is a 1, increment the count by 1.
After looping through all the bits, return the count.
Algorithm for computing the Hamming distance between two integers:
Initialize a variable count to 0.
Loop through each bit in the 32-bit integers x and y.

If the current bit in x is different from the current bit in y, increment the count by 1.
After looping through all the bits, return the count.
Program:
#include <stdio.h>
unsigned int hammingDistance(unsigned int x, unsigned int y)

{
unsigned int dist = 0;
unsigned int val = x ^ y; // bitwise XOR of x and y

while (val) {
// count the number of set bits (i.e., 1s) in val dist++;
val &= val - 1;
}

return dist;
}
int main() {
unsigned int x = 10; unsigned int y = 15;
printf("%u\n", hammingDistance(x, y)); return 0;

OUTPUT:
2
Result: Thus the program is executed and verified successfully.

 executed and verified successfully.
